// Это однострочный комментарии в JavaScript (эти строки выполняться интерпретатором не будут)

/*
Это многострочный
комментарий
*/

// Для того, чтобы видеть, что находится в переменных, в результате выполнения кода, будем выводить их в консоль
// Используя следующую конструкцию:
console.log("Сообщение:", 'Сам код смотри в файле /js/script.js');
// Всё, что находится в круглых скобках, данной конструкции будет выведено в консоль,
// то, что находится в двойных кавычках до запятой, будет пояснять результат чего выводится в консоль (для удобства),
// а то, что идет после запятой и будет результатом вычислений или самими вычислениями
// https://developer.mozilla.org/ru/docs/Web/API/Console


// https://www.youtube.com/watch?v=Bluxbh9CaQ0

//------------- 1. Переменные --------------
console.groupCollapsed('------------- 1. Переменные --------------'); // Позволяет в консоли группировать данные под единым заголовком
// Кликайте по зоголовкам тем в консоли, для того чтобы развернуть их сожержимое

// Переменная - это именованный участок памяти компьютера, для хранения какой-либо информации
// var - это сокращение от variable,
// далее идёт имя самой переменной 
// имя должно начинаться с латинских букв или символов "_", "$"", но может содержать  цифры, не должно совпадать с зарезервированными словами
// затем идет знак присвоения "=" и то, что мы помещаем в переменную, в данном случае строка 'Вася' (строки всегда пишут в ковычках, неважно одинарные или двойные)
// Символ ";" ставить в конце каждой команды не обязательно, за исключением некоторых редких случаев
// var - устаревшая конструкция, сейчас используют const или let, не рекомендуется использовать var
var firstName = 'Вася';
console.log("firstName:", firstName); // Выведет в консоль: Вася

// Способ записи слов в названиях переменных без пробелов, но каждое слово с большой буквы называют "СamelСase"
// const - это константа, то есть, задав ей значение, его нельзя будет поменять в дальнейшем (это касается примитивных типов данных)
const lastName = 'Петров';
console.log("lastName:", lastName); // Выведет в консоль: Петров

// Числовое значение записывают без ковычек
let age = 25;
console.log("age:", age); // Выведет в консоль: 25
console.groupEnd(); // Конец группировки

//------------- 2. Типы данных -------------
console.groupCollapsed('------------- 2. Типы данных -------------');
// https://learn.javascript.ru/types
// JavaScript - это динамически типизируемый язык программирования
// То есть JavaScript сам определяет тип переменной, если она не указана строго
// В зяыке JavaScript есть 8 типов данных (5 примитивных и 2 специальных типа)
let a = 5;
a = 'Я JavaScript программист!';
console.log("a:", a); // Выведет в консоль: Я JavaScript программист!
// То есть сначала мы присвоили переменной числовое значение "5"
// Затем заменили его на строковое "Я JavaScript программист!"
// И это не вызвало ошибки, так как JavaScript сам определил, что тип с числового 
// заменился на строковый - это называется "Мутирование"

// Cуществует шесть примитивных типов данных (содержат простые значения)
// 1. Number - Числовой (любые числа), значение указывается без ковычек
console.log(typeof 5); // Выведет в консоль: number, так как оператор typeof показывает тип переменной
console.log(typeof 5.5); // Выведет в консоль: number
// Кроме обычных чисел, существуют так называемые «специальные числовые значения», 
// которые относятся к этому типу данных: Infinity, -Infinity и NaN
// Infinity - Бесконечность
// -Infinity - Минус бесконечность
// NaN - Нечисло (Как это не парадоксально, но "нечисло" является числовым типом данных)
console.log(typeof Infinity); // Выведет в консоль: number
console.log(typeof -Infinity); // Выведет в консоль: number
console.log(typeof NaN); // Выведет в консоль: number

// 2. BigInt позволяет работать с целыми числами произвольной длины, так как тип "number" ограничен
// Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала или вызовом функции BigInt()
console.log(typeof 9573484848374555223n); // Выведет в консоль: bigint
console.log(typeof BigInt(9573484848374555223)); // Выведет в консоль: bigint

// 3. String - Строковые (любой текст), значение всегда указывается в кавычках
console.log(typeof 'Вася'); // Выведет в консоль: string
console.log(typeof '5'); // Выведет в консоль: string
console.log(typeof ''); // Выведет в консоль: string

// 4. Boolean - Логический, принемает дсего два значения true (истинное) и false (ложное)
// Значение указывается без кавычек
console.log(typeof true); // Выведет в консоль: boolean
console.log(typeof false); // Выведет в консоль: boolean

// 5. Undefined - Неопределенный, изначально переменная имеет именно такой тип данных
// То есть, если переменная создана, но значение ей не присвоено, то оно будет - undefined
let x;
console.log(typeof x); // Выведет в консоль: undefined

// 6. Symbol - Символ, используется для создания уникальных идентификаторов в объектах
// Его тоже рассмотрим позже
console.log(typeof Symbol("id")); // Выведет в консоль: symbol


// Так же в JavaScript есть 2 специальных типа:

// 1. Null - Нулевой (ничего, пустота), если мы хотим сказать, что в нашей переменной ничего нет, 
// то нужно использовать значение null, так как 0 - это число (что тоже по сути значение)
// Значение указывается без кавычек
console.log(typeof null); // Выведет в консоль: object - это баг JavaScript
console.log(null); // Выведет в консоль: null

// 2. Object - Объекты, хранят коллекции данных или более сложные структуры
// Объекты занимают важное место в языке и требуют особого внимания
// Можно сказать, что в языке JavaScript всё есть объекты (даже примитивы)
// Но об этом ниже, сейчас достаточно знать, что есть такой тип данных
let b = {
    firstName: 'Вася',
    lastName: 'Пупкин',
    age: 25
};

console.log(typeof b); // Выведет в консоль: object

// 3. Есть еще условный девятый тип данных (mdn относит его к таковым) - Function, 
// хотя на самом деле - это тип данных Object (так как функции это объекты, но об этом поговорим ниже)

console.log(typeof (() => null)); // Выведет в консоль: function
console.groupEnd();


//------------- 3. Арифметические операции --------------
console.groupCollapsed('------------- 3. Арифметические операции --------------')
// С переменными, в которых хранятся числовые значения, можно производить все те же арифметические операции, что и с числами

let d = 35;
let e = 5;
let f =  d + e; // Сложить
console.log("d + e:",f); // Выведет в консоль: 40
f =  d - e; // Вычисть
console.log("d - e:", f); // Выведет в консоль: 30
f =  d * e; // Умножить
console.log("d * e:", f); // Выведет в консоль: 175
f =  d / e; // Делить
console.log("d / e:", f); // Выведет в консоль: 7
f =  d ** e; // возвести в степень
console.log("d ** e:",f); // Выведет в консоль: 52521875

// Так же можно взять значение из переменной, 
// провести над ним арифметическую операцию и результат положить в ту же переменную
d = d + e; 
console.log("d + e:", d); // Выведет в консоль: 40
// Но это выражение можно сократить таким образом
d += e; // Равнозначно этому d = d + e;
console.log("d += e:", d); // Выведет в консоль: 45
d -= e; // Равнозначно этому d = d - e;
console.log("d -= e:", d); // Выведет в консоль: 40
d *= e; // Равнозначно этому d = d * e;
console.log("d *= e:", d); // Выведет в консоль: 200
d /= e; // Равнозначно этому d = d / e;
console.log("d /= e:", d); // Выведет в консоль: 40

// Так же существует оператор инкримента (Увеличения на 1)

let g = 0;

// Постфиксный - сначала возвращает значение, а затем добавляет единицу
console.log("Постфиксный инкримент:", g++); // Выведет в консоль: 0
console.log("Постфиксный инкримент:", g); // Выведет в консоль: 1
// Префиксный - сначала прибавит единицу, а затем вернет значение
console.log("Префиксный инкримент:", ++g); // Выведет в консоль: 2

// Также операция декримента (Уменьшение на 1)
// Постфиксный
console.log("Постфиксный декримент:", g--) // Выведет в консоль: 2
console.log("Постфиксный декримент:", g); // Выведет в консоль: 1
// Префиксный
console.log("Префиксный декримент:", --g); // Выведет в консоль: 0

// Запись чисел
// https://learn.javascript.ru/number
// Большие числа можно сокращать указываем число "e" затем количество нулей
const billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
console.log("billion:", billion); // Выведет в консоль: 1000000000

// Шестнадцатеричные числа
// Для короткой записи шестнадцатеричного числа используется префикс "0x"
console.log("Шестнадцатеричное число:", 0xff); // Выведет в консоль: 255
console.log("Шестнадцатеричное число:", 0xFF); // Выведет в консоль: 255 (регистр не имеет значения)

// Двоичные и восьмеричные числа
console.log("Двоичное число:", 0b11111111); // Выведет в консоль: 255
console.log("Восьмеричное число:", 0o377); // Выведет в консоль: 255

// Встроенный объект Math - является хранилищем различных математических констант и функций (не работает с числами типа BigInt)

// Округление
// Метод Math.floor - округление в меньшую сторону
console.log("Math.floor(5.1):", Math.floor(5.1)); // Выведет в консоль: 5
// Метод Math.ceil - округление в большую сторону
console.log("Math.ceil(5.1):", Math.ceil(5.1)); // Выведет в консоль: 6
// Метод Math.round - округление до ближайшего целого
console.log("Math.round(5.1):", Math.round(5.1)); // Выведет в консоль: 5
console.log("Math.round(5.6):", Math.round(5.6)); // Выведет в консоль: 6
// Метод Math.trunc - производит удаление дробной части без округления
console.log("Math.trunc(5.6):", Math.trunc(5.6)); // Выведет в консоль: 5

// Поскольку всё в JavaScript является объектом, то у числа можно выхвать встроеные методы

// Метод toFixed - округляет число до n знаков после запятой и возвращает строковое представление результата
console.log("5.123.toFixed(1):", 5.123.toFixed(1)); // Выведет в консоль: 5.1 (обратите внимание вернёт строку)

// В JavaScript из-за особенности хранения данных, при работе с числами есть такая ошибка - потеря точности
console.log("0.1 + 0.2 === 0.3:", 0.1 + 0.2 === 0.3); // Выведет в консоль: false
console.log("0.1 + 0.2:", 0.1 + 0.2); // Выведет в консоль: 0.30000000000000004 (Вот он баг! С другими числами тоже может возникать)
// Решение данной проблемы, "обрезать" число до нужного знака точности
let num = 0.1 + 0.2;
console.log("num:", num); // Выведет в консоль: 0.30000000000000004
console.log("num.toFixed(1):", num.toFixed(1)); // Выведет в консоль: 0.3 (но в строковом типе данных)
// Приведём к числу, для этого можно поставить знак "+" перед строкой или передать строку как аргумент Number()
console.log("+num.toFixed(1):", +num.toFixed(1)); // Выведет в консоль: 0.3 (а это уже число)
// Вот такие вот извращения ;)

// Проверка специфичных числовых значений
// Для проверки является или число NaN
console.log("NaN === NaN:", NaN === NaN); // Выведет в консоль: false
// NaN не равно даже самому себе, оно уникально
// isNaN(value) преобразует значение в число и проверяет является ли оно NaN
console.log("isNaN(NaN):", isNaN(NaN)); // Выведет в консоль: true
console.log("isNaN('str'):", isNaN('str')); // Выведет в консоль: true

// Проверка на конечность бесконечность
// isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity
console.log("isFinite(555):", isFinite(555)); // Выведет в консоль: true
console.log("isFinite('str'):", isFinite('str')); // Выведет в консоль: false (так как это NaN)
console.log("isFinite(Infinity):", isFinite(Infinity)); // Выведет в консоль: false

// Другие математические функции
// Часто нужно сгененировать псевдослучайное число
// Метод Math.random() - Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)
console.log("Math.random():", Math.random()); // Выведет в консоль: случайное число от 0 до 1

// Максимальное и минимальное значение помогут получить методы Math.max(a, b, c...) и Math.min(a, b, c...)
console.log("Math.max(15, 9, 3, 55, 7):", Math.max(15, 9, 3, 55, 7)); // Выведет в консоль: 55
console.log("Math.min(15, 9, 3, 55, 7):", Math.min(15, 9, 3, 55, 7)); // Выведет в консоль: 3

// Math.pow(n, power) - Возвращает число n, возведённое в степень power (можно использовать оператор "**" вместо этого метода)
console.log("Math.pow(5, 2):", Math.pow(5, 2)); // Выведет в консоль: 25
console.log("5 ** 2:", 5 ** 2); // Выведет в консоль: 25



// В языке JavaScript возможно сложение строк, данное действие называется "конкатенация"
let k = 'Один';
let l = 3
k += ', ' + 2 + ', '; // В данном случае, 2 это число, JavaScript приведет его к строке и "вклеит" в строку
k += l + ', '
console.log("Конкатенация:", k + 'Четыре'); // Выведет в консоль: Один, 2, 3, Четыре

// Есть еще более удобный способ конкатенации использовать обратные ковычки `` (клавиша с буквой Ё, при английской раскладке клавиатуры)
const m = `Один, 
2, ${l}, Четыре`; // Для вставки значения переменной в строку необходимо использовать конструкцию ${имя переменной}
// Кстати, в этом случае работают переносы строк
console.log('Конкатенация:', m); // Выведет в консоль: Один,  
                                    //2, 3, Четыре
console.groupEnd();


//------------- 4. Операторы сравнения --------------
console.groupCollapsed('------------- 4. Операторы сравнения --------------');
// a > b, a < b - a "больше" b, a "меньше" b
console.log("5 > 3:", 5 > 3); // Выведет в консоль: true
console.log("5 < 3:", 5 < 3); // Выведет в консоль: false
// a >= b, a <= b - a "больше или равно" b, a "меньше или равно" b
console.log("5 >= 3:", 5 >= 3); // Выведет в консоль: true
console.log("5 <= 3:", 5 <= 3); // Выведет в консоль: false
console.log("5 >= 5:", 5 >= 5); // Выведет в консоль: true
console.log("5 <= 5:", 5 <= 5); // Выведет в консоль: true
// a == b - a "равно" b - (Обратите внимание используется "==", так как "=" это знак присвоения значения переменной)
// a != b - a "не равно" b - ("!" - символ отрицания)
console.log("5 == 5:", 5 == 5); // Выведет в консоль: true
console.log("5 != 5:", 5 != 5); // Выведет в консоль: false
console.log("5 == '5':", 5 == '5'); // Выведет в консоль: true
console.log("5 != '5':", 5 != '5'); // Выведет в консоль: false
// Как вы заметили, сравнение числового и строчного значения вернуло истинный результат
//  Так как JavaScript автоматически привел типы данных к общему и сравнил содержимое
// Для того, чтобы сравнить значения не приводя их тип используют "===" и "!=="
// (их рекомендуется использовать всегда, поможет избежать ошибок!) 
// a === b - a "равно" b
// a === b - a "неравно" b
console.log("5 === 5:", 5 === 5); // Выведет в консоль: true
console.log("5 !== 5:", 5 !== 5); // Выведет в консоль: false
console.log("5 === '5':", 5 === '5'); // Выведет в консоль: false
console.log("5 !== '5':", 5 !== '5'); // Выведет в консоль: true

console.groupEnd();

//------------- 5. Приоритет операторов --------------
console.groupCollapsed('------------- 5. Приоритет операторов --------------');
// Что выполнится раньше вычитание или сравнение в следующем примере:
const h = 15 - 5 >= 7;
// https://developer.mozilla.org/ru/     --- справочная документация по JavaScript
// Наш вопрос смотрим здесь:
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
console.log("h:", h); // Выведет в консоль: true
console.groupEnd();

//------------- 6. Условные операторы --------------
console.groupCollapsed('------------- 6. Условные операторы --------------');

// Условный оператор if - если, а так же else - иначе
let color = 'red';

if(color === 'red'){
    console.log('Стой'); // Выведет в консоль: Стой
}

if(color === 'green'){
    console.log('Иди');  // Не выполнится, так как условие вернет false
}else{
    console.log('Стой'); // Выведет в консоль: Стой
}

color = 'yellow'

if(color === 'green'){
    console.log('Иди'); // Не выполнится, так как условие вернет false
} else if(color === 'yellow'){
    console.log('Внимание'); // Выведет в консоль: Внимание
}else{
    console.log('Стой'); // Не выполнится, так как, условие уже выполнилось
}

// Так же можно сокращать условия:
let j = true;

if(j){
   console.log('Значение переменной true'); // Выведет в консоль это значение
}else{
   console.log('Значение переменной false'); // Выведет, если изменить на j = false;
}

// Также значение к false приводятся: 0, null, undefined и пустая строка
j = 0;
if(j){
    console.log('Значение переменной true');
}else{
    console.log('Значение переменной false'); // Выведет в консоль это значение
}

j = null;
if(j){
    console.log('Значение переменной true');
}else{
    console.log('Значение переменной false'); // Выведет в консоль это значение
}

j = undefined;
if(j){
    console.log('Значение переменной true');
}else{
    console.log('Значение переменной false'); // Выведет в консоль это значение
}

j = '';
if(j){
    console.log('Значение переменной true');
}else{
    console.log('Значение переменной false'); // Выведет в консоль это значение
}

j = ' '; // Обратите внимание пробел, это тоже строковый символ, и эта страка не является пустой
if(j){
    console.log('Значение переменной true'); // Выведет в консоль это значение
}else{
    console.log('Значение переменной false');
}

// Для сокращения кода также часто используют тернарные операторы
// условие ? выражение1 : выражение2
// Выражение ниже полностью аналогично выражению выше, но записано тернарными операторами
j ? console.log('Значение переменной true') : console.log('Значение переменной false'); // Выведет в консоль: Значение переменной true


// Если у вас есть множество условий, которые зависят от значения одной переменной, 
// то используйте условный оператор switch

switch(color){ // color - входящий параметр
    case 'green': // если параметр равен данному условию, то выполнится ниже идущий код до следующего case
        console.log('Иди'); // Этот код не выполнится, не соответствует условию
        break; // Прерывает выполнение дальнейшего кода блока switch, так как зачем его проверять если истинное условие найдено
    case 'yellow':
        console.log('Внимание'); // Выведет в консоль: Внимание
        break;
    case 'red':
        console.log('Стой'); // Не выполнится, так как условие уже выполнилось и прерывание сработало
                            // К тому же условие выполнилось бы с ложным результатом
        break;
    default: // Если ни одно из условий не сработало как истинное, то по умолчанию отработает уже идущий код
        console.log('Стой'); // Сработал бы по умолчанию
}
console.groupEnd();

//------------- 7. Логические операторы --------------
console.groupCollapsed('------------- 7. Логические операторы --------------');
// Существует три логических оператора: 
// 1. уже знакомый нам ! "НЕ - отрицание"
// 2. || "ИЛИ" (Для того чтобы поставить вертикальный слеш используйте сочетание клавиш Shift + \ в английской раскладке клавиатуры)
// 3. && "И" (Для того, чтобы поставить амперсанд используйте сочетание клавиш Shift + 7 в английской раскладке клавиатуры)

// ИЛИ
console.group('--- ИЛИ ---')
// Традиционно в программировании ИЛИ предназначено только для манипулирования булевыми значениями: 
// в случае, если какой-либо из аргументов true, он вернёт true, в противоположной ситуации 
// возвращается false
// В JavaScript, как мы увидим далее, этот оператор работает несколько иным образом
// Давайте сперва рассмотрим традиционную логику

console.log("true || true:", true || true); // Выведет в консоль: true
console.log("true || false:", true || false); // Выведет в консоль: true
console.log("false || true:", false || true); // Выведет в консоль: true
console.log("false || false:", false || false); // Выведет в консоль: false

// Обычно булеву логику используют с условными операторами, для того чтобы объеденить несколько условий
const n = 10;
if(5 < n || n > 20){
    console.log('Условие 1 сработало');
}

// Рассмотрим специфическую логику JavaScript
// Возвращает первое истинное значение, если все значения ложны, то вернет последнее ложное
// Синтаксис: result = value1 || value2 || value3;
// Вычисление идёт слева направо

const o = 7 - 3 - 4 || 1000 * 0 || 5 + 5 || 100 + 100;
console.log("o:", o); // Выведет в консоль: 10

// Сокращенные вычисления - когда || заменяет if
// Синтаксис: value1 || value2
// Вычисление value2 производится не будет если value1 вернет значение true
let p;
5 + 5 || (p = 5); // Первое значение 10, что будет интерпретировано как истинное (true) и последующее вычисления производиться не будут
console.log("p:", p); // Выведет в консоль: undefined
3 - 3 || (p = 3); // Так как первое значение 0, (false) то будет произведено дальнейшее вычисление
console.log("p:", p); // Выведет в консоль: 3
console.groupEnd();

// И
console.group('--- И ---')
// В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false
console.log("true && false:", true && false); // Выведет в консоль: false
console.log("false && true:", false && true); // Выведет в консоль: false
console.log("false && false:", false && false); // Выведет в консоль: false
console.log("true && true:", true && true); // Выведет в консоль: true

if(5 < n && n > 20){
    console.log('Условие 2 сработало'); // Данное значение не будет выведено в консоль
}

// Рассмотрим специфическую логику JavaScript
// Возвращает первое ложное значение, если все значения истинны, то вернет последнее истинное
// Синтаксис: result = value1 && value2 && value3;
// Вычисление идёт слева направо
let q;
q = 3 - 2 && 5 - 5 && 3 + 2; // Второе значение 0, интерпретируется как false
console.log("q:", q); // Выведет в консоль: 0
 
// && иногда может заменять if
let r;
3 - 3 && (r = 3); // Так как первое значение 0, (false) то не будет произведено дальнейшее вычисление
console.log("r:", r); // Выведет в консоль: undefined
5 + 5 && (r = 5); // Первое значение 10, что будет интерпретировано как истинное (true) и последующее вычисления производиться будут
console.log("r:", r); // Выведет в консоль: 5
console.groupEnd();

// НЕ
console.group('--- НЕ ---');
// Приводит значение к логическому и меняет его на противоположное
// Синтаксис: result = !value;
console.log("!true:", !true); // Выведет в консоль: false
console.log("!0:", !0); // Выведет в консоль: true

// Иногда двойное отрицание используется для приведения значений к логическому типу
console.log("!!'Вася':", !!'Вася'); // Выведет в консоль: true
console.groupEnd();
console.groupEnd();


//------------- 8. Циклы --------------
console.groupCollapsed('------------- 8. Циклы --------------');
// Очень часто при программировании встаёт задача выполнять одни и те же действия много раз
// Цикл позволяет многократно повторять один и тот же блок кода
// https://learn.javascript.ru/while-for
// Одно выполнение тела цикла по-научному называется итерация
// В JavaScript присутствует несколько видов циклов:
// 1. Цикл "while":
console.group('--- while ---');
// Синтаксис:  while (условие) { тело цикла };
let z = 5;
while(z){ // Условие, пока оно истинно (true, то есть z != 0) цикл будет повторяться
    // Это тело цикла, весь код, который находится здесь, будет повторяться
    z--;
    console.log("z:", z); // Выведет в консоль: все z от 4 до 0
};

// Код такого вида:
// while(true){ //будет выполняться вечно }

// 2. Иногда бывает нужно, чтобы тело цикла гарантированно выполнилось хотя бы раз 
// и в зависимости от результата выполнилось повторно или нет
// Это позволяет сделать цикл "do ... while":
// Синтаксис: do { // тело цикла } while (условие);
let u = 1;
do{
    console.log("u:", u); // Выведет в консоль: 1
    u--;
}while(u);

console.groupEnd();


// 3. Цикл "for" имеет следующий вид:
console.group('--- for ---');
// Синтаксис:  for (начало; условие; шаг) { тело цикла };
for(let i = 0; i < 5; i++){ // i это переменная с начальным значением 0 (можно задать нужное), увеличивается каждый раз на 1, пока не выполнится условие
    // Это тело цикла, весь код, который находится здесь, будет повторяться 
    console.log("i:", i); // Выведет в консоль: все i от 0 до 4
};

// Код такого вида:
// for(;;){ //будет выполняться вечно };

// Бывает необходимость экстренно прервать цикл, сделать это можно с помощью специальной дерективы break
for(let t = 0; t < 100; t++){
    console.log("t:", t); // Выведет в консоль: все t от 0 до 4, а затем break прервет цикл
    if(t === 4){
        break; // Прервет цикл
    }
}

// Встречаются случаи, когда нужно пропустить одну или несколько итераций, для этого предназначена деректива continue
for(let w = 0; w < 10; w++){
    if(w % 2 === 0) continue; // Будет пропускать итерацию, если число делится без остатка
    console.log("w:", w); // Выведет в консоль: все не чётные числа от 0 до 10 
}

// break и continue нельзя использовать справа от тернарного оператора "?"
// w % 2 == 0 ? console.log(w) : continue; // приведет к ошибке

// Циклы могут выполняться внутри других циклов
for(let x = 0; x < 3; x++){
    console.log("x:", x);
    for(let q = 0; q < 3; q++){
        console.log("q:", q);
    };
};

// Тут появляется задача прервать несколько уровней циклов, для этого применяют метки
// Метка имеет вид идентификатора с двоеточием перед циклом
off:for(let s = 0; s < 3; s++){
    console.log("s:", s);
    for(let n = 0; n < 3; n++){
        if(n === 1 && s === 1 ) break off;
        console.log("n:", n);
    };
};
console.groupEnd();
console.groupEnd();



//------------- 9. Функции --------------
console.groupCollapsed('------------- 9. Функции --------------');
// Функция - это именованный фрагмент кода, которому можно обратиться из другого места программы
// Но в JavaScript существуют и анонимные функции

// Функции в языке программирования JavaScript объявляют двумя способами

// 1. Function Declaration (Объявление Функции)
console.group('--- Function Declaration ---');
// Обьявляем переменную с именем sayHi
function sayHi(){
    console.log('Hi!'); // Данный код не выполнится, пока мы не вызовем функцию по имени
}

sayHi(); // Вызов функции по имени. Выведет в консоль: Hi!
sayHi(); // Вызовем данную функцию еще раз. Снова Выведет в консоль: Hi!
console.groupEnd();


// 2. Function Expression (Функциональное Выражение)
console.group('--- Function Expression ---');
// Поскольку функция в JavaScript это тоже объект, но можно присвоить её переменной или константе
const sayHello = function(){
    console.log('Hello!'); // Данный код не выполнится, пока мы не вызовем функцию по имени
}

sayHello(); // Вызов функции по имени. Выведет в консоль: Hello!
sayHello(); // Вызовем данную функцию еще раз. Снова Выведет в консоль: Hello!

// Есть одна существенная разница в этих двух вариантах:
// Функция обьявленная декларативным способом (Function Declaration) может быть вызвана по имени ещё до её обьявления
// Так как такие функции JavaScript-инторпритатором, еще до выполнения скрипта, вырезаются и перемещаются в самый верх скрипта

sayGoodMorning(); // Вызываем функцию до её обьявления, и это не вызовет ошибки. Выведет в консоль: Good Morning!

function sayGoodMorning(){
    console.log('Good Morning!');
}

// Если до обьявления вызвать функцию типа Function Expression, то произойдёт ошибка!
console.groupEnd();

console.group('--- Стрелочные функции ---');
// Существует сокращённый способ обьявления функции типа Function Expression, так называемая стрелочная функция
const sayHowAreYou = () => console.log('How are you?'); 

sayHowAreYou(); // Выведет в консоль: How are you?

// Далее пойдет общая информация для функции, неважно каким из способов она объявлена

// В функцию можно передfвать некоторые аргументы (переменные)
// проводить с данными аргументами действия и затем возвращать результат

function sum(a, b){ // Обьявляем функцию sum и аргументами передаем в нее "a" и "b"
    return a + b; // Суммируем "a" и "b" и возвращаем результат используя оператор return
}

const res = sum(5, 10); // Вызываем функцию sum и передаём в неё занчения 5 и 10, результат записываем в константу res

console.log(res); // Выводим содержимое константы в консоль. Выведет в консоль: 15

// Если забыть указать любой из аргументов при вызове данной функции, то произойдёт функция вернет NaN (нечисло)
// Для того чтобы избежать такой ситуации, можно задать значение аргумента по умолчанию, 
// присвоив ему значение при обьявлении функции

function sum2(a = 3, b = 4){
    return a + b;
}

const res2 = sum2(); // Забываем передать аргументы, но ошибки не будет

console.log("res2:", res2); // Выведет в консоль: 7

// Такая же функция в стрелочном виде:
const sum3 = (a = 3, b = 4) => {
    return a + b;
}

const res3 = sum3(); // Вызываем нашу стрелочную функцию

console.log("res3:", res3); // Выведет в консоль: 7

// Если в стрелочную функцию передаётся всего один аргумент и этот аргумент обязательный (то есть не имеет значения по умолчанию)
// то круглые скобки можно опустить, но если аргументов нет, то пустые круглые скобки обязательны
// Также фигурные скобки и оператор return тоже можно опустить, если функция записывается в одну строку
// https://learn.javascript.ru/arrow-functions-basics

const sayMyName = name => 'Добро пожаловать, ' + name + '!';

console.log(sayMyName('Вася')); // Выведет в консоль: Добро пожаловать, Вася!

// Давайте посмотрим, что нам покажет оператор typeof если мы с помощью него посмотрим на функцию
console.log(typeof sayMyName); // Передадим функцию, не вызывая (без круглых скобок). Выведет в консоль: function

// На самом деле нет такого типа данных как "function", функции в языке программирования это объекты "object"
// Но для того. чтобы проще было отличить функцию от любого другого объекта, разработчики языка добавили такую возможность

// Если функция - это объект, значит её передать в качестве аргумента в другую функцию
console.groupEnd();
console.group('--- Колбэк-функция (Call-back) ---');
// Колбэк-функция (или обратный вызов) - это функция, переданная в другую функцию в качестве аргумента, 
// которая затем вызывается по завершению какого-либо действия.

const getPhrase = sayMyName => sayMyName('Коля') + ' Как твои дела?'; // Вызываем функцию внутри другой функции
const phrase = getPhrase(sayMyName); // Передали функцию в качестве аргумента
console.log(phrase); // Выведет в консоль: Добро пожаловать, Коля! Как твои дела?
console.groupEnd();

// Ещё есть возможность передавать в функцию не ограниченное число аргументов, 
// на случай, если мы не знаем точно сколько их будет
// Для этого существует специальный оператор, который называется rest и представляет из себя три точки "..."
// Он собирает в себя остаточные аргументы, и обязательно должен быть последним!
const names = (a, b, ...c) =>{
    console.log(a); // Выведет в консоль: Маша
    console.log(b); // Выведет в консоль: Даша
    console.log(c); // Выведет в консоль: ['Глаша', 'Наташа'] - что является массивом, но о них поговорим ниже
}
names('Маша', 'Даша', 'Глаша', 'Наташа');
console.groupEnd();



//------------- 10. Область видимости переменных --------------
console.groupCollapsed('------------- 10. Область видимости переменных --------------');
// Scope - Область видимости (доступности) переменных в функциях
// Существует глобальная область видимости и локальная:

// Глобальная область видимости - это когда переменная обявленна вне функции,
// но доступна для всех функций
// Например в браузере глобальные объекты window или document, они доступны вовсех функциях
// (являются api браузера и не являются частью языка JavaScript, но доступны нам если мы пишем web-приложение)

// Локальная область видимости - это когда переменная доступна только в рамках конкретной функции и вложенных в нее

function funcA(){
    let a = 1;

    function funcB(){
        let b = 2;

        function funcC(){
            let c = 3;

            console.log("funcC:", a, b, c); // Доступны переменные a, b и с
        }
        funcC(); // Вызываем функцию
        console.log("funcB:", a, b); // Доступны переменные a и b
    }
    funcB(); // Вызываем функцию
    console.log("funcA:", a); // Доступна только переменная a
}

funcA(); // Вызываем функцию
// Здесь недоступна ни одна из переменных инициализированных в функции funcA() и в неё вложенных

// Можно создавать закрытую область видимости блоком из фигурных скобок
let score = 10; // Эта переменная в глобальной области видимости

{
    let score = 1000; // Эта переменная в локальной области видимости, 
    // обратите внимание, что мы её здесь создаем, а не переназначаем, поэтому она существует параллельно
    // глобальная область видимости не имеет к ней доступа
    // Но тут доступна переменная score из глобальной области видимости, и переназначить мы её можем так score = 3000;
    console.log("локальный score:", score); // Выведет в консоль: 1000
}

console.log("глобальный score:", score); // Выведет в консоль: 10, так как это переменная из глобальной области видимости
console.groupEnd();

//------------- 11. Чистые функции --------------
console.groupCollapsed('--- 11. Чистые функции ---');
// Чистая функция - это функция, которая выводит свои данные основываясь 
// исключительно на свои входные данные и не вызывает побочных эффектов в приложении

// Сейчас будет "грязная функция" и так делать не надо!

const s = 5;
function bad(){ // Аргументом не передается никаких данных
    return s + 7; // Данные для вычислений берутся извне (в данном случаи глобальной области видимости)
}

console.log("bad:", bad()); // Выведет в консоль: 12

// Таким образом, есть вероятность что где-то в скрипте значение глобальной переменной изменится,
// а так же данную функцию нельзя переиспользовать в другом скрипте, так как она привязана к глобальной переменной


// Как будет выглядеть "чистая функция"

function good(s){ // передавая аргумент, мы делаем функцию независимой, даже если мы её перенесем в другой скрипт, нужно просто передать аргумент при вызове
    return s + 7;
}

console.log("good:", good(s)); // Выведет в консоль: 12
console.groupEnd();

//------------- 12. Замыкание --------------
console.groupCollapsed('------------- 12. Замыкание --------------');
// Замыкание - это комбинация функции, при котором внутренняя функция дает доступ к области видимости внешней функции
// Есть несколько вариантов замыкания:
// 1. Замыкание аргумента (иметация приватной переменной)
function sumСlosure(){
    const x = 10;
    return function(y){
        return x + y;
    }
}

const newSum = sumСlosure(); // Вернет нам функцию
const resultSum = newSum(7); // Передаем ей аргумент y
console.log("Замыкание, имитация приватной переменной, результат:", resultSum); // Выведет в консоль: 17
// Получается, что переменная x в данном случаи замкнута в функции newSum, и становится приватной,
// тоесть, прямого доступа к ней не имеем

// 2. Замыкание входящего аргумента
function sumСlosure2(x){
    return function(y){
        return x + y;
    }
}

const newSum2 = sumСlosure2(10); // Передаём аргумент x, а вернет нам функцию
const resultSum2 = newSum2(7); // Передаем ей аргумент y
console.log("Замыкание входящего аргумента, результат:", resultSum2); // Выведет в консоль: 17
// Получается, что аргумент x замыкается в функции newSum2, хотя в данных функция такой переменной нет
console.groupEnd();

//------------- 13. Генераторы --------------
console.groupCollapsed('------------- 13. Генераторы --------------');
// https://www.youtube.com/watch?v=7wtbNNiOh30
// Генераторы являются функциями с возможностью выхода и последующего входа. 
// Их контекст исполнения (значения переменных) сохраняется при последующих входах
// Синтаксис: function* name([param[, param[, ... param]]]) { yield ... yield ... }
function* idGen(){
    for(let i = 0; i < 3; i++){
        yield 'Id' + i;
    }
}

const id = idGen();

console.log(id.next());
console.log(id.next());
console.log(id.next());
console.log(id.next());

console.groupEnd();

//------------- 14. Объекты --------------
console.groupCollapsed('------------- 14. Объекты --------------');
// Весь наш Мир состоит из объектов, JavaScript использует тот же подход
// Объекты - это структуры данных, содержащие в себе данные и инструкции по работе с ними
// Обьект содержит данные в свойствах (это можно сказать переменные объекта)
// А инструкции по работе с данными в методах (это функции объекта)
// Объект инициализируется на основе класса (class)
// Класс - это чертеж, на основе которого можно создать множество объектов
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes
// В JavaScript классы это специфичные функции, поэтому как и функции Вы можете определить классы с помощью:
// Сlass declaration и Сlass expression

// 1. Сlass declaration
console.group('--- Сlass declaration ---');
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/class
// Синтаксис: class className [extends] { тело класса };

class Car{
    engine = true; // Свойство

    constructor(model, color){ // Функция конструктор, которая выполнится автоматически при создании объекта
        this.model = model; // Таким образом добавляется еще свойство
        this.wheels = 4;
        this.color = color;
    }

    drive(speed = 100){
        this.speed = speed;
        return this.model + ' едет вперёд со скоростью ' + speed + 'км/ч';
    }

}

// Для создания объекта на основе класса используется оператор new
const BmwX6 = new Car('BMW X6', 'Чёрный'); // Создаём объект
console.log("BmwX6:", BmwX6); // Выведет в консоль: всю структуру объекта
console.log("BmwX6.drive(120):", BmwX6.drive(120)); // Выведет в консоль: BMW X6 едет вперёд со скоростью 120км/ч
console.log("BmwX6.engine", BmwX6.engine);

// Создадим еще один объект используя тот же класс
const AudiTT = new Car('Audi TT', 'Серебристый металлик');
console.log("AudiTT:", AudiTT); // Выведет в консоль: всю структуру объекта
console.log("AudiTT.drive(90):", AudiTT.drive(90)); // Выведет в консоль: Audi TT едет вперёд со скоростью 90км/ч

// Так есть возможность наследования новых классов от уже существующих
// Например Экскаватор вилочный погрузчик это тоже машина, но с дополнительными возможностями
// Для того, чтобы нам заново не писать все его свойства, можно просто унаследовать имеющиеся и добавить собственные
// Используется оператор extends для указания от какого класса наследоваться
// Синтаксис: class parentСlassName extends childСlassName { тело класса };

class Forklift extends Car{

    constructor(model, color, liftingCapacity){ // Допустим, мы хотим перезаписать конструктор, с некоторыми дополнениями
        super(model, color); // Для обращения к функциям и методам родителя используем ключевое слово super
        // полностью возьмем конструктор родителя (если не перезаписывать метод родителя, он просто унаследуется целиком)
        this.liftingCapacity = liftingCapacity; // Добавим ему при инициализации новое свойство "грузоподъемность"
    }

    // В конструкторе ключевое слово super() используется как функция, вызывающая родительский конструктор. 
    // Её необходимо вызвать до первого обращения к ключевому слову this в теле конструктора
    // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/super

    liftUp(){
        return 'Поднимаю';
    }

    putDown(){
        return 'Опускаю вниз';
    }
}

const Hyundai15D = new Forklift('Hyundai 15D', 'Жёлтый', '2 тонны');

console.log("Hyundai15D:", Hyundai15D); // Выведет в консоль: всю структуру объекта
console.log("Hyundai15D.drive(5):", Hyundai15D.drive(5)); // Выведет в консоль: Hyundai 15D едет вперёд со скоростью 5км/ч
console.log("Hyundai15D.liftUp():", Hyundai15D.liftUp()); // Выведет в консоль: Поднимаю
console.log("Hyundai15D.liftingCapacity:", Hyundai15D.liftingCapacity); // Выведет в консоль: 2 тонны

// Статические метады и свойства класса
// Ключевое слово static, определяет статический метод или свойства для класса
// Они не могут быть вызваны у экземпляра класса (объекта)
// Статические методы часто используются для создания служебных функций для приложения, 
// в то время как статические свойства полезны для кеширования в рамках класса, 
// фиксированной конфигурации или любых других целей, несвязанных с копированием данных между экземплярами

class Dog{
    static name = 'Бобик';

    static wagging(){
        return 'Виляет хвостом';
    }
};

console.log("Dog.name:", Dog.name); // Выведет в консоль: Бобик
console.log("Dog.wagging():", Dog.wagging()); // Выведет в консоль: Виляет хвостом

const objDog = new Dog();
console.log("objDog.name:", objDog.name); // Выведет в консоль: undefined
console.log("objDog.wagging:", objDog.wagging); // Выведет в консоль: undefined
console.groupEnd();

// 2. Class expression
console.group('--- Class expression ---');
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/class
// Синтаксис: const MyClass = class [className] [extends] { тело класса };

const Bike = class {
    constructor(model, color){
        this.model = model;
        this.color = color;
    }

    drive(speed = 10){
        this.speed = speed;
        return this.model + ' едет вперёд со скоростью ' + speed + 'км/ч';
    }
}

const Bmx = new Bike('BMX', 'Синий');

console.log("Bmx.model:", Bmx.model); // Выведет в консоль: BMX
console.log("Bmx.drive():", Bmx.drive(15)); // Выведет в консоль: BMX едет вперёд со скоростью 15км/ч
console.groupEnd();

// Контекст
console.group('--- Контекст (this) ---');
// https://www.youtube.com/watch?v=UGapN-hrekw
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this
// Вы наверное заметели, что мы при объявлении свойств класса использовали ключевое слово "this" (этот) - это контекст
// this - хранит в себе ссылку на объект, в контексте которого мы к ней обращаемся
// То с помощью него мы можем обращаться к свойствам и методам объекта не зная имя этого объекта,
// Даже если объект будет переприсвоен (переименован) то обращение к методу или свойству не изменится

// В глобальном контексте выполнения (за пределами каких-либо функций) this ссылается на глобальный объект вне зависимости от режима
// в браузере это объект Windows
// Про режимы можно посмотреть тут: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode
console.log("Глобальный this:", this); // Выведет в консоль: всю структуру объекта Windows (если код выполнен браузером)

// Контекст можно передать в методы другого объекта спомощью методов bind, call и apply
// Метод bind - создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение
// Синтаксис: let bound = func.bind(context, [arg1], [arg2], ...);

// Метод call - тоже самое что и bind, но сразу же вызывает данную функцию
// Для примера возьмём ранее созданные объекты
const newDrive = BmwX6.drive.bind(AudiTT, 70);
console.log("newDrive():", newDrive()); // Выведет в консоль: Audi TT едет вперёд со скоростью 70км/ч

// Метод apply - ничем не отличается от метода call кроме того, что вторым параметром аргумменты в виде массива 
// Подробно массивы рассмотрим ниже

console.groupEnd();


console.group('--- Инициализация объектов ---');
// В JavaScript есть два способа создать объект, не создавая для этого отдельный класс
// Способ первый:
const Obj1 = new Object();
Obj1.name = 'Костя';
console.log("Obj1.name:", Obj1.name); // Выведет в консоль: Костя

// Способ второй (именно он рекомендуется к основному применению):
const Obj2 = {
    name: 'Ваня',
}
console.log("Obj2.name:", Obj2.name); // Выведет в консоль: Ваня

// Рассмотрим этот способ подробнее:
const persone = {
    constructor(){console.log('Создан объект persone!')},
    employeeName: 'Вася',
    employeeSurname: 'Пупкин',
    yearOfBirth: 1999,
    isProgrammer: true,
    languagers: ['ru', 'en'], // Массивы, рассмотрим далее
    employeeAge(){ // Функция вычесляет текущий возраст
        return (new Date()).getFullYear() - persone.yearOfBirth; // Не обращайтесь так к свойствам объекта (persone.yearOfBirth),
        // в данном случае лучше использовать this.yearOfBirth, так как объект может быть переприсвоен и внешняя сылка пропадет
    },
    'complex id': 'iD123',
    ['key' + (1 + 4)]: 'Computed Key',
    city: 'Москва',
    height: 180,
    duck:{ // Свойства объектов могут содержать другие объекты
        name: 'Джек',
        levl: 'senior',
        say: () => 'Кря'
    }
};
// Обращаться к методам и свойствам обьекта можно через точку (имяОбъекта.свойство)
console.log("persone.employeeName:", persone.employeeName); // Выведет в консоль: Вася
console.log("persone.employeeAge()", persone.employeeAge()); // Выведет в консоль текущий возраст Васи, зависит от года, когда вы смотрите данный скрипт

// Также можно обращаться к свойствам объекта через строковую составляющую с помощью квадратных скобок []
console.log("persone['employeeSurname']:", persone['employeeSurname']); // Выведет в консоль: Пупкин
console.log("persone['complex id']:", persone['complex id']); // Выведет в консоль: iD123

// Переопределение значений в свойствах
persone.city = 'Новосибирск';
console.log("persone.city:", persone.city); // Выведет в консоль: Новосибирск
// Обратите внимание! У нас объект persone является константой, но переназначать свойства мы можем

// Для удаления свойств и методов у объекта необходимо воспользоваться оператором delete
delete persone.height;

console.log("persone:", persone); // Выведет в консоль структуру объекта
console.log("persone.duck.name:", persone.duck.name); // Обращение к объектам в свойствах другого объекта 
console.log("persone.duck.say():", persone.duck.say());
console.groupEnd();

console.group('--- Деструктуризация ---');
// Деструктуризация - это особый синтаксис присваивания, при котором можно присвоить массив или 
// объект сразу нескольким переменным, разбив его на части
// В фигурных скобках перечисляем свойства и методы, которые хотим получить в отдельную переменную через запятую, 
// если нужно через двоеточие можем присвоить новое имя, а также задать значение по умолчанию,
// и присваеваем объект из которого мы хотим их получить
const {employeeName: newName = 'Коля', employeeSurname} = persone;

console.log("newName:", newName); // Выведет в консоль: Вася
console.log("employeeSurname:", employeeSurname); // Выведет в консоль: Пупкин
console.groupEnd();

// Сравнение объектов
console.group('--- Сравнение объектов ---');
// Два объекта равны только в том случае, если это один и тот же объект
console.log("{} === {}:", {} === {}); // Выведет в консоль: false

// При копировании объект не копируется, копируется ссылка на него, это отличие от примитивных типов данных

let apple = {
    name: 'Яблоко'
}

orange = apple;

orange.name = 'Апельсин';

console.log("apple.name:", apple.name); // Выведет в консоль: Апельсин
// Как мы видим свойство name изменилось у обекта apple, потому как сам объект не скопировался
console.groupEnd();

// Глубокое и не глубокое копирование
console.group('--- Глубокое и не глубокое копирование ---');
// https://nuancesprog.ru/p/4443/

// Для того, чтобы скопировать объект можно использовать оператор spread - "..."
const myCar = {
    model: 'KIA Rio',
    maxSpeed: 240,
    engine:{
        cylinders: 4,
        volume: 2
    }
};

const myNewCar = {...myCar}; // По сути создаем новый объект, разбирая старый объект на ключ:значение

myNewCar.model = 'Toyota Mark II';

console.log("myCar.model:", myCar.model); // Выведет в консоль: KIA Rio
console.log("myNewCar.model:", myNewCar.model); // Выведет в консоль: Toyota Mark II

myNewCar.engine.volume = 3;

console.log("myCar.engine.volume:", myCar.engine.volume); // Выведет в консоль: 3
console.log("myNewCar.engine.volume:", myNewCar.engine.volume); // Выведет в консоль: 3

// Как мы видим глубина копирования ограничена, 
// для того, чтобы скопировать можно преобразовать объект в json формат и затем обратно,
// воспользуемся встроенным объектом JSON и его методами

const jsonCar = JSON.stringify(myCar); // Преобразовываем объект myCar в json строку
console.log("jsonCar:", jsonCar); // Выведет в консоль: json строку
const  myJsonCar = JSON.parse(jsonCar); // Преобразовываем нашу json строку обратно в объект

myJsonCar.model = 'Ford Focus 3';
myJsonCar.engine.volume = 3.5;
console.log("myCar.model:", myCar.model); // Выведет в консоль: KIA Rio
console.log("myCar.engine.volume:", myCar.engine.volume); // Выведет в консоль: 3

console.log("myJsonCar.model:", myJsonCar.model); // Выведет в консоль: Ford Focus 3
console.log("myJsonCar.engine.volume:", myJsonCar.engine.volume); // Выведет в консоль: Ford Focus 3
console.groupEnd();
// К сожалению таким способом нельзя скопировать методы объекта
// Для этого нужно использовать отдельные библиотеки

// В JavaScript есть встроенный объект Object для работы с объектами
// Например: для получения всех ключей свойств и методов объекта Object.keys (вернет массив названий всех методов и свойств)
console.log("Object.keys(persone):", Object.keys(persone)); // Выведет в консоль: ['constructor', 'employeeName', 'employeeSurname', 'yearOfBirth', 'isProgrammer', 'languagers', 'employeeAge', 'complex id', 'key5', 'city', 'duck']

// Рекомендую ознакомиться:
// Ещё способы работы с объектими (Что такое getters, setters) https://www.youtube.com/watch?v=cS6nTVNzOPw
console.groupEnd();


//------------- 15. Прототипы (Prototype) --------------
console.groupCollapsed('------------- 15. Прототипы (Prototype) --------------');
// https://www.youtube.com/watch?v=aQkgUUmUJy4
// https://developer.mozilla.org/ru/docs/Learn/JavaScript/Objects/Object_prototypes
// JavaScript часто описывают как язык прототипного наследования — каждый объект, 
// имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и 
// свойства. Объект-прототип так же может иметь свой прототип и наследовать его свойства и 
// методы и так далее. Это часто называется цепочкой прототипов и объясняет почему одним 
// объектам доступны свойства и методы которые определены в других объектах.

// Создание нового метода или свойства в прототипе осуществляется с помощью обращения к 
// глобальному классу Object (именно от него наследуются все) и его свойству prototype 
const testProto = {
    test: 'Это тест прототипа!',
};

Object.prototype.sayJS = () => console.log('JavaScript!');

testProto.sayJS(); // Выведет в консоль: JavaScript!


const Lena = {
    name: 'Елена',
    introduceHimself(){
        console.log(`Здравствуйте. Я ${this.name}.`);
    }
}
// Метод create - создает объект, в качестве прототипа нового обьекта, получает другой объект как аргумент
const Vova = Object.create(Lena);

Vova.name = 'Владимир';
Vova.introduceHimself();
console.groupEnd();

//------------- 16. Массивы --------------
console.groupCollapsed('------------- 16. Массивы --------------');
// https://learn.javascript.ru/array
// Массив - это упорядоченная коллекция данных, подвид объектов
// Обьявляются массивы двумя способами:
const array1 = new Array('Петя', 'Вася', 'Дима');
console.log("array1:", array1); // Выведет в консоль: ['Петя', 'Вася', 'Дима']

const array2 = ['Петя', 'Вася', 'Дима'];
console.log("array2:", array2); // Выведет в консоль: ['Петя', 'Вася', 'Дима']
// Предпочтительней второй вариант

// Если развернуть массив в консоли, то мы увидим, что данные хранятся в массиве в следующем виде:
// [0:'Яблоко', 1:'Апельсин', 2:'Груша'] - то есть данные хранятся в виде [ключ:значение]
// Числовой ключ присваивается автоматически и называется индекс, он всегда начинается с ноля
// К элементу массива можно обращаться по индексу:
console.log("array1[1]:", array1[1]); // Выведет в консоль: Вася, так как элемент под индексом 1 именно он

// Общее число элементов массива содержится в его свойстве length
console.log("array1.length:", array1.length); // Выведет в консоль: 3
// Кстати, "обрезать" или обнулить массив можно задав его длинну array1.length = 0;

// В массиве могут храниться элементы любого типа

const array3 = ['Стол', {name: 'Бобик'}, true, 5, NaN, function(){ return 1}, null];
console.log("array3:", array3); // Выведет в консоль: ['Стол', {…}, true, 5, NaN, ƒ, null]

// Добавление и удаление элементов в массив:
const array4 = ['Audi', 'Mazda'];

// Метод push - добавляет элемент в конец массива
array4.push('Ford');
console.log("array4.push('Ford'):", array4); // Выведет в консоль: ['Audi', 'Mazda', 'Ford']

// Метод shift - удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым
console.log("array4.shift():", array4.shift()); // Выведет в консоль: Audi (так как возвращает, содержимое удаляемого элемента)

console.log("array4:", array4); // Выведет в консоль: ['Mazda', 'Ford']

// Метод pop - удаляет последний элемент массива
console.log("array4.pop():", array4.pop()); // Выведет в консоль: Ford (так как возвращает, содержимое удаляемого элемента)

console.log("array4", array4); // Выведет в консоль: ['Mazda']

// Метод unshift - добавляет элемент в начало массива
array4.unshift('Honda');
console.log("array4.unshift('Honda'):", array4); // Выведет в консоль: ['Honda', 'Mazda']
// Методы push и unshift могут добавлять сразу несколько элементов, через запятую

// Изменение элементов массива
array4[0] = 'Mercedes'; // Обратите внимание, что содержимое элемента можно менять даже если массив объявлен как const
console.log("array4[0] = 'Mercedes':", array4); // Выведет в консоль: ['Mercedes', 'Mazda']

// Таким же способом можно добавить элемент в конец массива, указав следующий индекс
array4[2] = 'Ford';
console.log("array4[2] = 'Ford':", array4); // Выведет в консоль: ['Mercedes', 'Mazda', 'Ford']

// Если мы незнаем последнего индекса, то можно сделать так
array4[array4.length] = 'Honda';
console.log("array4[array4.length]:", array4); // Выведет в консоль: ['Mercedes', 'Mazda', 'Ford', 'Honda']
// Не работайте с массивами как с обычными объектами, иначе их эффективность теряется
// array4[1000] = 'Mitsubishi'; // Ненадо так!

// Многомерные массивы, тоесть элементами массива могуд быть другие массивы
const matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

console.log("matrix:", matrix); // Выведет в консоль: [Array(3), Array(3), Array(3)] (нажмите на треугольник в консоли, чтобы развернуть)
console.log("matrix[1][1]:", matrix[1][1]); // Выведет в консоль: 5

console.log("array4.toString():", array4.toString()); // Выведет в консоль: Mercedes,Mazda,Ford,Honda

// Если требуется удалить элемент, например, из середины массива, то delete
delete array4[1];
console.log("delete array4[1]:", array4); // Выведет в консоль: ['Mercedes', , 'Ford', 'Honda'] (смещения массива не происходит)

// https://learn.javascript.ru/array-methods

// Метод splice - это универсальный "швейцарский нож" для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы
// Синтаксис: arr.splice(index[, deleteCount, elem1, ..., elemN]);
// Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов
const array5 = ['Яблоко', 'Груша', 'Слива', 'Апельсин'];
const delResult = array5.splice(1, 2, 'Ананас'); // Удалит начиная с 1 индекса 2 элемента, а на их место поставит элемент "Ананас"
console.log("array5.splice(1, 2, 'Ананас'):", array5); // Выведет в консоль: ['Яблоко', 'Ананас', 'Апельсин']
console.log("delResult:", delResult); // Выведет в консоль: ['Груша', 'Слива']


// Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0
array5.splice(2, 0, 'Персик', 'Абрикос');
console.log("array5.splice(2, 0, 'Персик', 'Абрикос'):", array5); // Выведет в консоль: ['Яблоко', 'Ананас', 'Персик', 'Абрикос', 'Апельсин']


// Метод slice - Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end). 
// Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
// Синтаксис: arr.slice([start], [end]);
const copyArray = array5.slice(0, 3);
console.log("array5.slice(0, 3):", array5); // Выведет в консоль: ['Яблоко', 'Ананас', 'Персик', 'Абрикос', 'Апельсин']
console.log("copyArray:", copyArray); // Выведет в консоль: ['Яблоко', 'Ананас', 'Персик']


// Метод concat - создаёт новый массив, в который копирует данные из других массивов и дополнительные значения
// Синтаксис: arr.concat(arg1, arg2...);
const array6 = array5.concat(copyArray, 'Груша');
console.log("array5.concat(copyArray, 'Груша'):", array6); // Выведет в консоль: ['Яблоко', 'Ананас', 'Персик', 'Абрикос', 'Апельсин', 'Яблоко', 'Ананас', 'Персик', 'Груша']

// Также можно объединить несколько массивов оператором spred "..."
const array7 = [...array5, ...delResult];
console.log("array7:", array7); // Выведет в консоль: ['Яблоко', 'Ананас', 'Персик', 'Абрикос', 'Апельсин', 'Груша', 'Слива']


// Как оставить только уникальные элементы
// Объекты Set - позволяют вам сохранять уникальные значения любого типа
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Set
console.log("[...new Set(array6)]", [...new Set(array6)]); // Выведет в консоль: ['Яблоко', 'Ананас', 'Персик', 'Абрикос', 'Апельсин', 'Груша'] 


// Для перебора массива используют циклы:
for(let i = 0; i < array5.length; i++){
    console.log("array4[i]:", array5[i]); // Выведет в консоль: содержимое элементов массива
};

// Также для перебора массива можно использовать for..of
for(let i of array5){
    console.log("i:", i);
}


// Метод forEach - позволяет перебрать все элементы массива и для каждого элемента запустить функцию
// Синтаксис: arr.forEach(function(item, index, array) { // ... делать что-то с item });
['зелёный', 'красный', 'чёрный'].forEach((item, index, array) => console.log(item)); // Выведет в консоль: каждый элемент

// Метод indexOf - ищет элемент, начиная с указанного индекса, если был найден искомый элемент, возвращяет его индекс, в противном случае -1
// Синтаксис: arr.indexOf(item, from);
console.log("array6.insexOf('Ананас', 3):", array6.indexOf('Ананас', 3)); // Выведет в консоль: 6

// Метод lastIndexOf - то же самое, но ищет справа налево
// Синтаксис: arr.lastIndexOf(item, from);
console.log("array6.lastIndexOf('Ананас', 3):", array6.lastIndexOf('Ананас', 3)); // Выведет в консоль: 1

// Метод includes - ищет элемент, начиная с указанного индекса, если был найден искомый элемент, возвращяет true
// Синтаксис: arr.includes(item, from);
console.log("array6.includes('Ананас', 3):", array6.includes('Ананас', 3)); // Выведет в консоль: true
// Обратите внимание, что методы используют строгое сравнение ===

// Метод find - для каждого элемента выполняет функцию, в которую добовляем определенное условие, если функция вернет true,
// то метод faind возвращяет елемент, на котором это произошло, если таких елементов нет, вернёт undefined
// Синтаксис: let result = arr.find(function(item, index, array) {  if(item === 5){ return true} });
const gamers = [
    {id: 1, name: 'Толя'},
    {id: 2, name: 'Юра'},
    {id: 3, name: 'Слава'}
];

console.log("gamers.find(item => item.name === 'Юра'):", gamers.find(item => item.name === 'Юра')); // Выведет в консоль: {id: 2, name: 'Юра'}

// Метод findIndex - по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено

// Метод filter - схож с find, но возвращает массив из всех подходящих элементов
console.log("gamers.filter(item => item.id < 3):", gamers.filter(item => item.id < 3)); // Выведет в консоль: [{id: 1, name: 'Толя'}, {id: 2, name: 'Юра'}]

// Метод map - он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции
// Синтаксис: let result = arr.map(function(item, index, array) { // возвращается новое значение вместо элемента });
console.log("gamers.map(item => item.name.length):", gamers.map(item => item.name.length)); // Выведет в консоль: [4, 3, 5]

// Метод sort - сортирует массив на месте, меняя в нём порядок элементов
// Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам массив
// По умолчанию элементы сортируются как строки! Для создания собственного порядка сортировки, нам нужно предоставить функцию в качестве аргумента
const array8 = [1, 5, 9, 2, 11, 7];
function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
}

console.log("array8.sort(compareNumeric):", array8.sort(compareNumeric)); // Выведет в консоль: [1, 2, 5, 7, 9, 11]
console.log("array8.sort((a, b) => a - b):", array8.sort((a, b) => b - a)); // Выведет в консоль: [11, 9, 7, 5, 2, 1]

// Метод reverse - меняет порядок элементов на обратный
console.log("[1, 2, 3, 4, 5].reverse():",[1, 2, 3, 4, 5].reverse()); // Выведет в консоль: [5, 4, 3, 2, 1]

// Метод split - разбивает строку на массив по заданному разделителю
console.log("'Антон, Максим, Костя'.split(', '):", 'Антон, Максим, Костя'.split(', ')); // Выведет в консоль: ['Антон', 'Максим', 'Костя']
// У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. 
// Если их больше, чем указано, то остаток массива будет отброшен
// Вызов split() с пустым аргументом разбил бы строку на массив букв
console.log("'JavaScript'.split(''):",'JavaScript'.split('')); // Выведет в консоль: ['J', 'a', 'v', 'a', 'S', 'c', 'r', 'i', 'p', 't']

// Метод join - делает в точности противоположное split. Он создаёт строку из элементов массива, вставляя разделитель между ними
console.log("['Ирина', 'Анна', 'Ольга'].join(', '):", ['Ирина', 'Анна', 'Ольга'].join(', ')); // Выведет в консоль: Ирина, Анна, Ольга


// Методы reduce и reduceRight - они используются для вычисления какого-нибудь единого значения на основе всего массива
// Синтаксис: let value = arr.reduce(function(previousValue, item, index, array) { // ... }, [initial]);
// Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов
// previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial)
console.log("[1, 2, 3, 4, 5].reduce((sum, item) => sum + item, 0):", [1, 2, 3, 4, 5].reduce((sum, item) => sum + item, 0)); // Выведет в консоль: 15
// При отсутствии initial в качестве первого значения берётся первый элемент массива, а перебор стартует со второго
// Но если массив пуст и отсуствует initial, то будет ошибка

// Массивы не образуют отдельный тип данных
console.log("typeof []:", typeof []); // Выведет в консоль: object
// Для определения массивов нужно использовать метод Array.isArray(arr)
console.log("Array.isArray(array8):", Array.isArray(array8)); // Выведет в консоль: true
console.groupEnd();

//------------- 17. Строки --------------
console.groupCollapsed('------------- 17. Строки --------------');
// https://learn.javascript.ru/string
// В JavaScript любые текстовые данные являются строками
// Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы

// Для записи строк, есть три вида кавычек:
// 1. Одинарные 
console.log('Одинарные кавычки'); // Выведет в консоль: Одинарные кавычки

// 2. Двойные кавычки
console.log("Двойные кавычки"); // Выведет в консоль: Двойные кавычки

// 3. Обратные кавычки
console.log(`Обратные 
кавычки`);  // Выведет в консоль: Обратные
            //                    кавычки

// Преимущество обратных кавычек — они могут занимать более одной строки 
// Одинарные и двойные кавычки работают, по сути одинаково, а если использовать обратные кавычки, 
// то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}
console.log(`2 + 2 = ${ 2 + 2 }`); // Выведет в консоль: 2 + 2 = 4

// Если нужно перенести строку в Одинарных или Двойных кавычках, то можно использовать символ переноса \n
console.log('Одинарные \nкавычки'); // Выведет в консоль: Одинарные
                                    //                    кавычки

// Если нужно поставить такую же кавычку внутри кавычки, то можно ее экранировать обратным слэшем "\"
console.log('I\'m the programmer'); // Выведет в консоль: I'm the programmer

// Длину строки можно узнать вызвав у неё свойство length
console.log("'srt'.length:", 'str'.length); // Выведет в консоль: 3

// Получить символ, который занимает определённую позицию можно с помощью квадратных скобок [] или 
// с помощью метода charAt (отсчёт позиции от нуля)

console.log("'str'[1]:", 'str'[1]); // Выведет в консоль: t
console.log("'str'.charAt(1):", 'str'.charAt(1)); // Выведет в консоль: t

// Также можно перебрать строку посимвольно, используя for..of
for(let i of 'str'){
    console.log("i:", i);
}

// Содержимое строки в JavaScript нельзя изменить. 
// Нельзя взять символ и заменить его. Как только строка создана — она такая навсегда
console.log("'str'[1] = 'T':", 'str'[1] = 'T'); // Выведет в консоль: Т
// Можно только перезаписать строку

// Изменение регистра
// Метод toUpperCase - делает все символы в строке заглавными
console.log("'Java Script'.toUpperCase():", 'Java Script'.toUpperCase()); // Выведет в консоль: JAVA SCRIPT

// Метод  toLowerCase - делает все символы в строке строчными
console.log("'Java Script'.toLocaleLowerCase():", 'Java Script'.toLocaleLowerCase()); // Выведет в консоль: java script

// Метод indexOf - он ищет подстроку в строке, начиная с указанной позиции, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений
console.log("'Я программист на JavaScript'.indexOf(3, 'Java'):",'Я программист на JavaScript'.indexOf('Java', 3)); // Выведет в консоль: 17
// Так как индекс может быть 0, то использовать условие if через явное сравнение if(str.indexOf('искомое') !== -1)

// Метод lastIndexOf - ищет с конца строки к её началу

// Метод includes - возвращает true, если в строке есть подстрока, либо false, если нет
console.log("'Я программист на JavaScript'.includes('Java', 3):", 'Я программист на JavaScript'.includes('Java', 3)); // Выведет в консоль: true

// Методы startsWith и endsWith - проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой
console.log("'JavaScript'.startsWith('Ja'):", 'JavaScript'.startsWith('Ja')); // Выведет в консоль: true
console.log("'JavaScript'.endsWith('Ja'):", 'JavaScript'.endsWith('Ja')); // Выведет в консоль: false

// В JavaScript есть 3 метода для получения подстроки: substring, substr и slice

// Метод slice - возвращает часть строки от start до (не включая) end
// Синтаксис: str.slice(start [, end])
console.log("'JavaScript'.slice(0, 4):", 'JavaScript'.slice(0, 4)); // Выведет в консоль: Java

// Метод substring - возвращает часть строки между start и end (не включая) end (практически то же самое что и slice)
// Синтаксис: str.substring(start [, end])
console.log("'JavaScript'.substring(0, 4):", 'JavaScript'.substring(0, 4)); // Выведет в консоль: Java

// Метод substr - возвращает часть строки от start длины length
// Синтаксис: str.substr(start [, length])
console.log("'JavaScript'.substr(0, 4):", 'JavaScript'.substr(0, 4)); // Выведет в консоль: Java

// Метод codePointAt - возвращает код для символа, находящегося на позиции
console.log("'JavaScript'.codePointAt(3):", 'JavaScript'.codePointAt(3)); // Выведет в консоль: 97

// Метод fromCodePoint - создаёт символ по его коду
console.log("String.fromCodePoint(97):", String.fromCodePoint(97)); // Выведет в консоль: a
console.groupEnd();


//------------- 18. Storage --------------
console.groupCollapsed('------------- 18. Storage --------------');
// https://www.youtube.com/watch?v=3-bZ7gLVSzo
// Некоторые функции JavaScript не являются частью языка, а относятся к API браузера
// Например функция alert() или prompt(), то есть например в Node.js они работать не будут

// Storage - Интерфейс Storage из Web Storage API предоставляет доступ для session storage или 
// local storage для конкретного домена, позволяя вам, к примеру, добавлять, изменять или 
// удалять сохранённые элементы данных
// Позволяет хранить до 5мб данных пользователя в его браузере, которые будут доступны после перезагрузки страницы
// localStorage - Свойство localStorage позволяет получить доступ к Storage объекту

window.localStorage; // Доступен через глобальный объект window, но его можно опустить

localStorage.setItem('name', 'Вася'); // Добавляем новое поле в формате ключ, значение
localStorage.setItem('age', 25); // Хотя мы и передаём число, но хранить он всё в строковом формате

console.log("localStorage.getItem('name'):", localStorage.getItem('name')); // Выведет в консоль: Вася
console.log("localStorage.getItem('age'):", localStorage.getItem('age')); // Выведет в консоль: 25 (но это строка!)
// Доступно только для текущего домена!

localStorage.removeItem('name'); // Удаляет элемент
localStorage.clear(); // Очищает весь localStorage для данного домена

// Потому, что в localStorage может хранить только строки, для хранения объектов их нужно преобразовать в строку формата JSON
const car1 = {
    model: 'Audi TT',
    color: 'red'
}

localStorage.setItem('car', JSON.stringify(car1)); // JSON.stringify() преобразует обект в строку формата JSON
const car2 = JSON.parse(localStorage.getItem('car'));
console.log("car2:", car2);
localStorage.clear();

// sessionStorage - Свойство sessionStorage очень похоже на свойство Window.localStorage, 
// единственное различие заключается в том, что все данные, сохранённые в localStorage не 
// имеют определённого времени жизни, а данные в sessionStorage очищаются в момент окончания 
// сессии текущий страницы

console.groupEnd();

//------------- 19. Асинхронность --------------
console.groupCollapsed('------------- 19. Асинхронность --------------');
// JavaScript — это однопоточный язык программирования, в котором может быть выполнено только 
// что-то одно за раз. То есть, в одном потоке движок JavaScript может обработать 
// только 1 оператор за раз.

// Но чтобы откладывать выполнение некоторых задачь, но не останавливаать при этом 
// выполнение последующих задач есть механизм Event Loop (Событийный цикл)
// Подробно об этой технологии рассмотренно в этом видео: https://www.youtube.com/watch?v=vIZs5tH-HGQ

// Что такое Promise и как они работают: https://www.youtube.com/watch?v=1idOY3C1gYU

// Про то как работает Async, Await, fetch:  https://www.youtube.com/watch?v=SHiUyM_fFME

// Fetch, XMLHttpRequest (XHR), Ajax:  https://www.youtube.com/watch?v=eKCD9djJQKc
console.groupEnd();

//------------- 20. Работа с DOM-деревом --------------
console.groupCollapsed('------------- 20. Работа с DOM-деревом --------------');
// В соответствии с объектной моделью документа («Document Object Model», коротко DOM), 
// каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. 
// Текст, который находится внутри тега, также является объектом

// Все операции с DOM начинаются с объекта document. 
// Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу
console.log("document:", document); // Выведет в консоль: объект со всем нашим HTML документом (DOM-деревом)

// Важно где расположено подключение нашего JavaScripta (js/script.js) в HTML документе (index.html),
// Так как DOM-дерево может ещё не загрузится, а скрипт начать обращаться к его элементам
// Поэтой причине мы подключили данный скрипт с атрибутом "defer"
// https://learn.javascript.ru/script-async-defer 

// Рассмотрим часто используемые методы и свойства, подробней можно ознакомится здесь: https://learn.javascript.ru/document
// document.getElementById(id) - если у элемента есть id можно получить его спомощью метода getElementById
console.log("document.getElementById('modalWindow'):", document.getElementById('modalWindow')); // Выведет в консоль: наше модальное окно

// document.querySelectorAll(selectors) - самый универсальный метод поиска, он возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору
// https://developer.mozilla.org/ru/docs/Web/API/Document/querySelectorAll
console.log("document.querySelectorAll('div.menu'):", document.querySelectorAll('div.menu')); // Выведет в консоль: все div с классом "menu"
console.log("document.querySelectorAll('div.menu')[0]:", document.querySelectorAll('div.menu')[0]); // Выведет в консоль: первый div с классом "menu"
// Псевдоклассы в CSS-селекторе, в частности :hover и :active

// document.querySelector(selectors) - возвращает первый элемент, соответствующий данному CSS-селектору
console.log("document.querySelector('li.modal-form_doc-item'):", document.querySelector('li.modal-form_doc-item')); // Выведет в консоль: первый li с классом "modal-form_doc-item"

// Устаревшие, но используемые методы getElementsBy*
// document.getElementsByTagName(tag) - ищет элементы с данным тегом и возвращает их коллекцию
console.log("document.getElementsByTagName('li'):", document.getElementsByTagName('li'));
// document.getElementsByClassName(className) - возвращает элементы, которые имеют данный CSS-класс
console.log("document.getElementsByClassName('vs-block'):", document.getElementsByClassName('vs-block'));
// document.getElementsByName(name) - возвращает элементы с заданным атрибутом name
console.log("document.getElementsByName('docMoney'):", document.getElementsByName('docMoney'));

// Изменение класса является одним из наиболее часто используемых действий в скриптах
// elem.classList – это специальный объект с методами для добавления/удаления одного класса
// elem.classList.add/remove("class") – добавить/удалить класс
// elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить
// elem.classList.contains("class") – проверка наличия класса, возвращает true/false

// Свойство elem.style – это объект, который соответствует тому, что написано в атрибуте "style"
// Например, чтобы скрыть элемент, мы можем задать elem.style.display = "none"

// getComputedStyle(element, [pseudo]) - получает текушие значения свойств стиля у элемента
// Где element - Элемент, значения для которого нужно получить, а pseudo - Указывается, если нужен стиль псевдоэлемента, например ::before

let computedStyle = getComputedStyle(document.body);
console.log("computedStyle.color:", computedStyle.color); // Выведет в консоль: rgb(255, 255, 255)

console.groupEnd();

//------------- 21. Обработчики событий --------------
console.groupCollapsed('------------- 21. Обработчики событий --------------');
// События - это действия или случаи, возникающие в программируемой вами системе, 
// о которых система сообщает вам для того, чтобы вы могли с ними взаимодействовать

// Обработчик события - это функция соторая выполнится при определенном событии, 
// в нее может передаватся объект события (event, evt или e), для предоставления дополнительных функций и информации

// Для регистрации обработчика события используют метод EventTarget.addEventListener()
// Где EventTarget - обект поддерживающий события (Element, Document, Window и т. д.)
// https://developer.mozilla.org/ru/docs/Web/API/Event

console.log('Нажмите любую клавишу для создания события');
window.addEventListener('keydown', event => { // Обработчик на нажатие любой клавиши
    console.log("event:", event); // Выведем объект события в консоль
});

// Удалить событие можно спомощью метода EventTarget.removeEventListener()

console.groupEnd();
console.info("Добро пожаловать в консоль!");


// ++++++++++++++++ Если ты прошёл(а) всё что выше - моё почтение!  ++++++++++++++++++++ //
// +++++++++++++++++++++++++ Ты не реально крут(а)!!! ++++++++++++++++++++++++++++++++++ //

// А что дальше? ;)

// Рекомендую продолжить обучение, и "копать" в следующею сторону:
// 1. Начни изучать свой первый фреймворк! 
// Рекомендую - React, конечно это не совсем фреймворк, а библиотека, 
// поэтому нужно будет изучить дополнительные библиотеки, такие как Redux, redux-thunk и Redux-saga
// React официальная документация: https://ru.reactjs.org/docs/getting-started.html
// Урок по реакту: https://www.youtube.com/watch?v=xJZa2_aldDs
// React хуки (React Hooks): https://www.youtube.com/watch?v=9KJxaFHotqI

// Что такое Redux: https://www.youtube.com/watch?v=5Qtqzeh5FeM
// Redux подробный разбор: https://www.youtube.com/watch?v=YdYyYMFPa44

// Redux-saga:
// https://www.youtube.com/watch?v=ah5voE_SGjo
// https://www.youtube.com/watch?v=7Pq-2bBIzXY

// 2. Объектно-ориентированное программирование (ООП):
// https://www.youtube.com/watch?v=-6DWwR_R4Xk

// 3. Алгоритмы:
// https://www.youtube.com/watch?v=NErrGZ64OdE

// 4. Паттерны. Шаблоны проектирования:
// https://refactoring.guru/ru/design-patterns
// https://www.youtube.com/watch?v=YJVj4XNASDk

// 5. Также можно поришать задачки на:
//  https://www.codewars.com/

// 6. Также обратите своё внимание на систему контроля версий Git и GitHub:
// https://git-scm.com/
// https://www.youtube.com/watch?v=zZBiln_2FhM

// 7. Webpack:
// https://www.youtube.com/watch?v=eSaF8NXeNsA

// Желаю успехов!